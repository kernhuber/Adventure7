import os
from typing import List, Dict, Any, TypedDict
from langchain_core.messages import HumanMessage
from langgraph.graph import StateGraph, END
from langchain_google_genai import ChatGoogleGenerativeAI
import re

# Google API Key (Du musst deinen eigenen API-Key hier eintragen)
# os.environ["GOOGLE_API_KEY"] = "dein-google-api-key"
os.environ["GOOGLE_API_KEY"] = "AIzaSyBAD9VSVcw47HSj6I63qSGpY4vuuu7WXTA"

# Initialisiere das Gemini-Modell
llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash")


# Spielzustand definieren
class GameState(TypedDict):
    messages: List[Dict[str, Any]]  # Chat-Verlauf
    current_room: str  # Aktueller Raum-ID
    inventory: List[str]  # Gegenst√§nde, die der Spieler tr√§gt
    discovered: Dict[str, bool]  # Spezielle Zustandsflags (z.B. gefundene Gegenst√§nde)
    visited_rooms: List[str]  # R√§ume, die der Spieler besucht hat
    debug_mode: bool  # Schalter f√ºr Debug-Informationen
    game_over: bool  # Flag, um das Spiel zu beenden


# System-Prompt wie in der Beschreibung angegeben
SYSTEM_PROMPT = """
Du bist Parser UND Erz√§hler eines textbasierten Abenteuerspiels.

Bei jeder Benutzereingabe lieferst du sowohl einen Content als auch einen Tool-Call. Achte darauf, 
die Himmelsrichtungen (Norden, S√ºden, Osten, Westen) innerhalb eines Raumes und beim √úbergang zwischen R√§umen konsistent 
zu behandeln. Hier die generellen Regeln. Generell lieferst Du f√ºr jeden Raum:

1. Eine kurze, atmosph√§rische Beschreibung der Handlung im Textfeld (content) ‚Äì z.B.:

   "Du b√ºckst dich und hebst das Kissen auf. Darunter liegt etwas Gl√§nzendes."

2. Eine oder mehrere Funktionsaufrufe (ToolCalls), mit denen das Spielsystem die Welt ver√§ndern kann.

Beispiel:

Spielereingabe:
"Ich nehme das Kissen und √∂ffne die T√ºr nach Norden."

Antwort:

Content:
"Du nimmst das Kissen an dich. Dahinter entdeckst du einen alten Schl√ºssel. Mit einem Knacken √∂ffnet sich die T√ºr."

ToolCalls:
- nimm("kissen")
- nimm("schl√ºssel")
- benutze("schl√ºssel", "norden")
- gehe("norden")

Wenn der Spieler ‚ÄûQ", ‚ÄûQuit" oder ‚ÄûEnde" eingibt, ist das ein Wunsch, das Spiel zu verlassen.
In diesem Fall sollst du die Funktion `beenden()` aufrufen.

---

### üß† Wichtig f√ºr den Spielablauf:

Jede Antwort muss einen kurzen Text im Feld `content` enthalten ‚Äì auch wenn nur ToolCalls zur√ºckgegeben werden.  
Wenn du nichts beschreiben m√∂chtest, gib einen Platzhalter-Text wie z. B.  
- "(Du f√ºhrst die Aktion aus.)"  
- "(Nichts weiter geschieht.)"  
- oder einen stimmungsvollen Erz√§hlerkommentar an.  
- Gib niemals eine Antwort ohne `content`.
- Erw√§hne immer alle T√ºren und Wege des Raums; beschreibe dem Spieler, wohin er gehen kann

---

### üéÆ Deine Regeln f√ºr das Spiel:

* Wenn Du um Hilfe gebeten wirst, hilf dem Spieler gem√§√ü den Anweisungen in den einzelnen R√§umen, und
  liefere 'nop()' zur√ºck.
* Wenn der Spieler sehen m√∂chte, was er dabei hat, bzw. was er schon aufgesammelt hat, oder was er im
  "Inventory hat", dann liefere 'inventory()' zur√ºck
* Wenn der Spieler den Debug-Modus an oder ausschalten will, dann liefere 'debug("an")' oder debug("aus") 
  zur√ºck, je nachdem was der Spieler w√ºnscht. Wenn der Spieler nur den Status des Debug-Modus wissen will,
  dann liefere 'debug("status")' zur√ºck
* Wenn Du einen Raum beschreiben sollst, so beschreibe den Raum gem√§√ü den Anweisungen in den einzelnen 
  R√§umen, danach lieferst Du 'nop()' zur√ºck
* Du darfst mehrere Tool-Calls gleichzeitig ausgeben, wenn sinnvoll.
* Du darfst **implizite Aktionen erkennen** ‚Äì z.B. wenn jemand ‚ÄûIch gehe in die Bibliothek" sagt, dann:
   - `benutze("schl√ºssel", "norden")`
   - `gehe("norden")`
* Verwende nur Objekte, R√§ume und Richtungen, die dir bekannt sind.
* Der Spieler kann die T√ºr angeben, durch die er gehen will (Beispiel: "Gehe durch die T√ºr im Norden"), er kann 
  aber auch nur die Richtung angeben, in die er gehen will (Beispiel: "Gehe nach westen"). Liefere in allen F√§llen
  -- Eine Best√§tigung als content, etwa: "Du gehst durch die T√ºr im Westen"
  -- den korrekten Tool-call 'gehe()'
* Wenn du etwas nicht nnst (z.B. T√ºr verschlossen, kein Objekt vorhanden), √ºberlasse die Erkl√§rung dem Spielsystem.

---

### üß∞ Verf√ºgbare Funktionen:

- `umsehen()` ‚Üí beschreibt den aktuellen Raum
- `untersuche(gegenstand)` ‚Üí untersucht ein Objekt
- `nimm(gegenstand)` ‚Üí nimmt ein Objekt ins Inventar
- `benutze(gegenstand, ziel)` ‚Üí verwendet z.B. Schl√ºssel auf T√ºr
- `gehe(richtung)` ‚Üí geht in einen anderen Raum
- `eingabe_code(code)` ‚Üí gibt einen vierstelligen Code ein
- `hilfe()` ‚Üí gibt einen Hinweis, was der Spieler tun k√∂nnte
- `beenden()` ‚Üí beendet das Spiel
- `inventory()` ‚Üí Zeigt das Inventory an (also alles, was der Spieler aufgesammelt hat)
- `debug(modus)` ‚Üí Schaltet den Debug-Modus an oder aus
- `nop()` ‚Üí "No Operation".

---

Verwende in jeder Antwort mindestens einen passenden Funktionsaufruf, sofern dies durch die Eingabe des Spielers sinnvoll ausgel√∂st wird.
"""

# R√§ume definieren
ROOMS = {
    "start": {
        "beschreibung": "Du wachst in einem schlichten Zimmer auf. Es gibt ein Bett mit einem Kissen darauf. In der Ecke stehen eine Schaufel und eine Schere. Eine Nudelpackung liegt auf dem Boden. Es gibt zwei T√ºren: nach Westen (offen) und nach Norden (verschlossen).",
        "hinweis": "Vielleicht solltest du dich umsehen oder das Kissen genauer betrachten.",
        "gegenstaende": ["schaufel", "schere", "nudelpackung", "kissen"],
        "tueren": {
            "norden": {"ziel": "bibliothek", "verschlossen": True, "benoetigt": "schl√ºssel"},
            "westen": {"ziel": "durchgang", "verschlossen": False}
        },
        "extra_prompt": """
        Wenn der Spieler sich umsieht, beschreibe ihm den Raum. Dabei kannst Du etwas geheimnisvoll tun. Du bist ein guter Erz√§hler.
        * Beschreibe alle Objekte im Raum und auch alle T√ºren und Durchg√§nge. 
        * Wenn eine T√ºr verschlossen ist, erw√§hne das extra. 
        * Wenn der Spieler um Hilfe bittet, weise ihn darauf hin, dass das Kissen doch sehr weich aussieht.
        * Unter dem Kissen befindet sich ein Schl√ºssel, den der Spieler aber am Anfang nicht sieht.
        * Wenn der Spieler das Kissen untersucht oder aufnimmt, erw√§hne den Schl√ºssel unter dem Kissen
        """
    },
    "durchgang": {
        "beschreibung": "Ein schmuckloser Raum mit kahlen W√§nden. Auf einem alten Stuhl liegt ein Kochl√∂ffel. Eine Luftpumpe lehnt an der Wand. Ein Radio steht auf einem kleinen Tisch und spielt leise vor sich hin. T√ºren f√ºhren nach Osten und Westen.",
        "hinweis": "Vielleicht findest du hier etwas N√ºtzliches oder auch nicht.",
        "gegenstaende": ["radio", "luftpumpe", "kochl√∂ffel"],
        "tueren": {
            "osten": {"ziel": "start", "verschlossen": False},
            "westen": {"ziel": "endraum", "verschlossen": False}
        },
        "extra_prompt": """
            Wenn der Spieler sich umsieht, beschreibe den Raum und erw√§hne, dass der Stuhl mit dem Kochl√∂ffel im Osten steht und die Luftpumpe im Westen lehnt. Erw√§hne auch das Radio und die T√ºren nach Osten (zum Startraum) und Westen (zum Endraum).
    Wenn der Spieler um Hilfe bittet, erw√§hne, dass er Gegenst√§nde untersuchen und die T√ºren nach Osten (zum Startraum) oder Westen (zum Endraum) nutzen kann.
    Beschreibe die Gegenst√§nde humorvoll, wenn der Spieler sie untersucht.
        """
    },
    "bibliothek": {
        "beschreibung": """
        Du befindest dich in einer geheimen, staubigen Bibliothek. B√ºcher in unbekannter Sprache f√ºllen die Regale. 
        In der Ecke steht ein alter Ohrensessel. Es war lange niemand mehr hier, 
        deswegen ist alles mit Staub und Spinnweben √ºberzogen. In einer Ecke des Raums befindet sich ein verschlissener 
        Ohrensessel, daneben ein kleiner Tisch. Der Ohrensessel war bestimmt einmal gem√ºtlich, aber er ist nun mit Staub 
        bedeckt, und eine fette Spinne hat sich oben rechts auf ihm eingenistet und ein Spinnennetz 
        zwischen Sessel und Tisch gebaut. Auf dem Tisch liegt ein geheimnisvolles Buch.
        """,
        "hinweis": "Das Buch auf dem Tisch sieht anders aus als die anderen.",
        "gegenstaende": ["sessel", "tisch", "geheimnisvolles_buch"],
        "tueren": {
            "sueden": {"ziel": "start", "verschlossen": False}
        },
        "extra_prompt": """Du bist ein guter Erz√§hler! Wenn der Spieler sich umsieht, beschreibe ihm den Raum, alle Objekte
        und die T√ºr, die der einzige Ausgang ist.
        * Wenn der Spieler sich umsieht musst du ihm den Raum beschreiben, dabei 
          kannst du ihn in recht d√ºsteren Worten beschreiben. 
        * Der Spieler kann sich auch einzelne B√ºcher aus den Regalen ansehen, aber sie sind in 
          Geheimschrift verfasst, sodass der Spieler sie nicht verstehen kann. Das gilt nur f√ºr die B√ºcher im regal.
        * Das Buch auf dem Tisch kann der spieler untersuchen. Sobald er das tut, musst du ihn auf den Geheimcode hinweisen.
        * Wenn der Spieler das geheimnisvolle Buch auf dem Tisch untersucht findet er darin einen vierstelligen Geheimcode.
        * Der Spieler erf√§hrt den Geheimcode dadurch, dass er das geheimnisvolle Buch untersucht. Wenn er das Buch untersucht, gib ihm den Geheimcode
        * Der Spieler kann nur durch die T√ºre gehen, durch die er gekommen ist.
        """
    },
    "endraum": {
        "beschreibung": "Ein karger Betonraum mit einem Tastenfeld an der westlichen Wand. Sonst ist der Raum leer.",
        "hinweis": "Vielleicht brauchst du einen Code, um weiterzukommen.",
        "gegenstaende": [],
        "tueren": {
            "osten": {"ziel": "durchgang", "verschlossen": False},
            "westen": {"ziel": "freiheit", "verschlossen": True, "code": True}
        },
        "extra_prompt": """
        Der Endraum enth√§lt nichts au√üer dem Tastenfeld an der westlichen Wand. Weisen Sie den Spieler darauf hin, dass er einen Code eingeben muss, 
        um weiterzukommen. Der korrekte Code ist 4283, den der Spieler im geheimnisvollen Buch in der Bibliothek gefunden haben sollte.
        """
    },
    "freiheit": {
        "beschreibung": "Du trittst hinaus auf eine sonnige Sommerwiese. Du hast das Spiel erfolgreich beendet!",
        "hinweis": "",
        "gegenstaende": [],
        "tueren": {},
        "extra_prompt": """
        Dies ist der Gewinnerraum. Gratuliere dem Spieler zum erfolgreichen Abschluss des Spiels. Er kann hier nichts weiter tun.
        """
    }
}

# Gegenst√§nde definieren
ITEMS = {
    "schaufel": {
        "hinweis": "Eine rostige alte Schaufel. Vielleicht mal n√ºtzlich gewesen.",
    },
    "schere": {
        "hinweis": "Eine stumpfe Bastelschere. Nicht gef√§hrlich.",
    },
    "nudelpackung": {
        "hinweis": "Eine halb volle Packung Spaghetti. Haltbar bis 2027.",
    },
    "kissen": {
        "hinweis": "Ein gem√ºtliches Kissen. Vielleicht liegt etwas darunter?",
    },
    "schl√ºssel": {
        "hinweis": "Ein kleiner, leicht angerosteter Schl√ºssel.",
        "sichtbar": False,  # Anfangs unter dem Kissen versteckt
    },
    "radio": {
        "hinweis": "Ein altes Radio, aus dem leise Musik dringt.",
    },
    "luftpumpe": {
        "hinweis": "Eine quietschende Luftpumpe.",
    },
    "kochl√∂ffel": {
        "hinweis": "Ein Holzl√∂ffel mit eingebrannter Gravur: 'Mama'.",
    },
    "geheimnisvolles_buch": {
        "hinweis": "Ein altes, schweres Buch mit mystischem Einband.",
        "code": "4283"
    },
    "sessel": {
        "hinweis": "Ein alter Sessel mit staubigen Armlehnen.",
        "nimmbar": False
    },
    "tisch": {
        "hinweis": "Ein kleiner Tisch aus dunklem Holz.",
        "nimmbar": False
    }
}


# Hilfsfunktionen f√ºr spezielle Spielmechaniken
def _entdecke_schluessel(state):
    """Entdeckt den Schl√ºssel unter dem Kissen."""
    if "schl√ºssel" not in state["inventory"] and "kissen" in ROOMS[state["current_room"]]["gegenstaende"]:
        # Mache den Schl√ºssel sichtbar und verf√ºgbar
        ITEMS["schl√ºssel"]["sichtbar"] = True
        if "schl√ºssel" not in ROOMS[state["current_room"]]["gegenstaende"]:
            ROOMS[state["current_room"]]["gegenstaende"].append("schl√ºssel")
        state["discovered"]["schl√ºssel_entdeckt"] = True
        return "Du findest einen kleinen, rostigen Schl√ºssel unter dem Kissen!"
    return "Du untersuchst das Kissen. Es ist weich und gem√ºtlich."


def _entdecke_geheimnummer(state):
    """Entdeckt den Geheimcode im mysteri√∂sen Buch."""
    state["discovered"]["code_entdeckt"] = True
    return f"Du bl√§tterst durch das mysteri√∂se Buch und findest eine Seite mit einer handgeschriebenen Notiz: 'Der Code lautet {ITEMS['geheimnisvolles_buch']['code']}'"


# Tool-Funktionen, die vom LLM aufgerufen werden k√∂nnen
def umsehen(state):
    """Schaut sich im aktuellen Raum um."""
    current_room = state["current_room"]
    room_info = ROOMS[current_room]

    # Markiere den Raum als besucht
    if current_room not in state["visited_rooms"]:
        state["visited_rooms"].append(current_room)

    # Gib die Raumbeschreibung zur√ºck
    return room_info["beschreibung"]


def untersuche(state, gegenstand):
    """Untersucht einen Gegenstand im Raum."""
    current_room = state["current_room"]

    # Pr√ºfe, ob der Gegenstand im Raum oder Inventar ist
    if gegenstand in ROOMS[current_room]["gegenstaende"] or gegenstand in state["inventory"]:
        # Pr√ºfe auf spezielle Interaktionen
        if gegenstand == "kissen" and state["current_room"] == "start":
            return _entdecke_schluessel(state)
        elif gegenstand == "geheimnisvolles_buch" and state["current_room"] == "bibliothek":
            return _entdecke_geheimnummer(state)
        elif gegenstand in ITEMS:
            return ITEMS[gegenstand]["hinweis"]
        else:
            return f"Du untersuchst {gegenstand}, findest aber nichts Besonderes."
    else:
        return f"Hier gibt es kein {gegenstand} zum Untersuchen."


def nimm(state, gegenstand):
    """Nimmt einen Gegenstand auf und f√ºgt ihn dem Inventar hinzu."""
    current_room = state["current_room"]

    # Pr√ºfe, ob der Gegenstand im Raum ist
    if gegenstand in ROOMS[current_room]["gegenstaende"]:
        # Pr√ºfe, ob der Gegenstand aufnehmbar ist
        if gegenstand in ITEMS and ITEMS.get(gegenstand, {}).get("nimmbar", True) == False:
            return f"Du kannst {gegenstand} nicht mitnehmen."

        # Spezialfall f√ºr das Kissen - enth√ºlle den Schl√ºssel
        if gegenstand == "kissen" and state["current_room"] == "start":
            _entdecke_schluessel(state)

        # Zum Inventar hinzuf√ºgen und aus dem Raum entfernen
        if gegenstand not in state["inventory"]:
            state["inventory"].append(gegenstand)
            ROOMS[current_room]["gegenstaende"].remove(gegenstand)
            return f"Du nimmst {gegenstand} auf und steckst es ein."
        else:
            return f"Du hast {gegenstand} bereits bei dir."
    else:
        return f"Hier gibt es kein {gegenstand} zum Aufnehmen."


def benutze(state, gegenstand, ziel):
    """Verwendet einen Gegenstand auf ein Ziel (z.B. Schl√ºssel an T√ºr)."""
    current_room = state["current_room"]

    # Pr√ºfe, ob der Gegenstand im Inventar ist
    if gegenstand not in state["inventory"]:
        return f"Du hast kein {gegenstand} zum Benutzen."

    # Pr√ºfe, ob ein Schl√ºssel an einer T√ºr verwendet wird
    if gegenstand == "schl√ºssel" and ziel in ROOMS[current_room]["tueren"]:
        door = ROOMS[current_room]["tueren"][ziel]
        if door["verschlossen"] and door.get("benoetigt") == "schl√ºssel":
            door["verschlossen"] = False
            return f"Du benutzt den Schl√ºssel an der T√ºr nach {ziel}. Die T√ºr ist jetzt aufgeschlossen."
        elif not door["verschlossen"]:
            return f"Die T√ºr nach {ziel} ist bereits aufgeschlossen."
        else:
            return f"Der Schl√ºssel passt nicht zur T√ºr nach {ziel}."

    # Generischer Anwendungsfall
    return f"Du versuchst, {gegenstand} auf {ziel} anzuwenden, aber nichts passiert."


def gehe(state, richtung):
    """Bewegt sich in einen anderen Raum in der angegebenen Richtung."""
    current_room = state["current_room"]

    # Pr√ºfe, ob es eine T√ºr in der angegebenen Richtung gibt
    if richtung in ROOMS[current_room]["tueren"]:
        door = ROOMS[current_room]["tueren"][richtung]

        # Pr√ºfe, ob die T√ºr verschlossen ist
        if door["verschlossen"]:
            if door.get("code", False):
                return f"Die T√ºr nach {richtung} hat ein Codeschloss. Du musst zuerst den richtigen Code eingeben."
            else:
                return f"Die T√ºr nach {richtung} ist verschlossen. Vielleicht brauchst du einen Schl√ºssel?"

        # Wechsle den Raum
        next_room = door["ziel"]
        state["current_room"] = next_room

        # Markiere den neuen Raum als besucht
        if next_room not in state["visited_rooms"]:
            state["visited_rooms"].append(next_room)

        return f"Du gehst durch die T√ºr nach {richtung} und befindest dich nun in: {ROOMS[next_room]['beschreibung']}"
    else:
        return f"Es gibt keine T√ºr in Richtung {richtung}."


def eingabe_code(state, code):
    """Gibt einen vierstelligen Code ein, z.B. f√ºr eine T√ºr mit Codeschloss."""
    current_room = state["current_room"]

    # Pr√ºfe, ob wir im Endraum sind und die westliche T√ºr einen Code hat
    if current_room == "endraum" and "westen" in ROOMS[current_room]["tueren"]:
        door = ROOMS[current_room]["tueren"]["westen"]

        if door.get("code", False) and code == ITEMS["geheimnisvolles_buch"]["code"]:
            # Code ist korrekt
            door["verschlossen"] = False
            return "Das Tastenfeld blinkt gr√ºn auf. Mit einem Klicken √∂ffnet sich die T√ºr nach Westen."
        else:
            return "Das Tastenfeld blinkt rot. Der Code scheint falsch zu sein."
    else:
        return "Hier gibt es kein Codeschloss, f√ºr das du einen Code eingeben k√∂nntest."


def hilfe(state):
    """Gibt einen Hinweis zum aktuellen Raum."""
    current_room = state["current_room"]
    return ROOMS[current_room]["hinweis"]


def beenden(state):
    """Beendet das Spiel."""
    state["game_over"] = True
    return "Das Spiel wird beendet. Danke f√ºrs Spielen!"


def inventory(state):
    """Zeigt das Inventar des Spielers an."""
    if not state["inventory"]:
        return "Dein Inventar ist leer."
    else:
        return f"In deinem Inventar befinden sich: {', '.join(state['inventory'])}"


def debug(state, modus):
    """Schaltet den Debug-Modus an oder aus."""
    if modus == "an":
        state["debug_mode"] = True
        return "Debug-Modus ist jetzt aktiviert."
    elif modus == "aus":
        state["debug_mode"] = False
        return "Debug-Modus ist jetzt deaktiviert."
    elif modus == "status":
        status = "aktiviert" if state["debug_mode"] else "deaktiviert"
        return f"Debug-Modus ist aktuell {status}."
    else:
        return f"Ung√ºltiger Debug-Modus: {modus}"


def nop(state):
    """No Operation - tut nichts."""
    return "Keine Aktion ausgef√ºhrt."


# Funktionsregister (wird vom LLM referenziert)
FUNCTION_MAP = {
    "umsehen": umsehen,
    "untersuche": untersuche,
    "nimm": nimm,
    "benutze": benutze,
    "gehe": gehe,
    "eingabe_code": eingabe_code,
    "hilfe": hilfe,
    "beenden": beenden,
    "inventory": inventory,
    "debug": debug,
    "nop": nop
}


# Funktion zum Parsen der Tool-Calls aus der LLM-Antwort
def parse_tool_calls(response):
    """Extrahiert die Tool-Calls aus der LLM-Antwort."""
    # Regex-Muster f√ºr Tool-Calls wie: nimm("kissen"), benutze("schl√ºssel", "t√ºr"), etc.
    # pattern = r'([a-zA-Z_]+)\("([^"]*)(?:"(?:\s*,\s*"([^"]*)")?)?(?:\)'
    pattern = r'([a-zA-Z_]+)\("([^"]*)"(?:\s*,\s*"([^"]*)")?\)'

    # Alle Treffer finden
    matches = re.findall(pattern, response)

    # Als Liste von Dictionaries zur√ºckgeben
    tool_calls = []
    for match in matches:
        function_name = match[0]
        args = [arg for arg in match[1:] if arg]  # Leere Argumente entfernen

        tool_calls.append({
            "name": function_name,
            "arguments": args
        })

    return tool_calls


# Funktion zum Erstellen eines Raum-Prompts mit Kontext
def create_room_prompt(state):
    """Erstellt einen kontextspezifischen Prompt f√ºr den aktuellen Raum."""
    current_room = state["current_room"]
    room_info = ROOMS[current_room]

    # Basis-Prompt mit System-Prompt
    prompt = SYSTEM_PROMPT

    # Raum-spezifische zus√§tzliche Anweisungen
    if "extra_prompt" in room_info:
        prompt += "\n\n" + room_info["extra_prompt"]

    # Informationen √ºber aktuellen Raum
    prompt += f"\n\nAktueller Raum: {current_room}"
    prompt += f"\nRaumbeschreibung: {room_info['beschreibung']}"

    # Gegenstandsinformationen
    visible_items = []
    for item in room_info["gegenstaende"]:
        # √úberspringe versteckte Gegenst√§nde
        if item in ITEMS and not ITEMS[item].get("sichtbar", True):
            continue
        visible_items.append(item)

    prompt += f"\nGegenst√§nde im Raum: {', '.join(visible_items) if visible_items else 'keine'}"

    # T√ºrinformationen
    doors_info = []
    for direction, door in room_info["tueren"].items():
        status = "verschlossen" if door["verschlossen"] else "offen"
        doors_info.append(f"{direction} ({status}, f√ºhrt nach {door['ziel']})")

    prompt += f"\nT√ºren: {', '.join(doors_info) if doors_info else 'keine'}"

    # Inventarinformationen
    prompt += f"\nInventar des Spielers: {', '.join(state['inventory']) if state['inventory'] else 'leer'}"

    # Spezielle Zust√§nde
    if state["discovered"]:
        prompt += "\nEntdeckt:"
        for key, value in state["discovered"].items():
            prompt += f"\n- {key}: {value}"

    return prompt


# LLM-Anfragefunktion
def query_llm(state, user_input):
    """Sendet eine Anfrage an das LLM und verarbeitet die Antwort."""
    # Erstelle den Prompt mit Raumkontext
    context_prompt = create_room_prompt(state)

    # Debug-Ausgabe
    if state["debug_mode"]:
        print("\n--- DEBUG: Prompt f√ºr LLM ---")
        print(context_prompt)
        print("-----------------------------\n")

    # Anfrage an das LLM senden
    messages = [
        {"role": "system", "content": context_prompt},
        {"role": "user", "content": user_input}
    ]

    response = llm.invoke(messages)

    # Antwort auswerten
    ai_response = response.content

    # Content und Tool-Calls trennen
    content_parts = ai_response.split("ToolCalls:")

    content = content_parts[0].strip()
    if len(content_parts) > 1:
        tools_text = content_parts[1].strip()
        tool_calls = parse_tool_calls(tools_text)
    else:
        tool_calls = []

    # Debug-Ausgabe
    if state["debug_mode"]:
        print("\n--- DEBUG: LLM-Antwort ---")
        print(f"Content: {content}")
        print(f"Tool-Calls: {tool_calls}")
        print("---------------------------\n")

    return content, tool_calls


# Funktionen f√ºr den Zustandsgraphen
def process_input(state: GameState):
    """Verarbeitet die Benutzereingabe und erweitert den Zustand."""
    # Die letzte Nachricht des Benutzers abrufen
    user_input = state["messages"][-1]["content"]

    # Frage das LLM nach Inhalt und Tool-Calls
    content, tool_calls = query_llm(state, user_input)

    # Aktualisiere den Zustand
    #
    ## Changed role from "assistant" to "model"
    #
    state["messages"].append({
        "role": "assistant",
        "content": content,
        "tool_calls": tool_calls
    })

    return state


def execute_tools(state: GameState):
    """F√ºhrt die vom LLM angeforderten Tool-Calls aus."""
    # Die letzte Antwort des LLM abrufen
    last_assistant_msg = state["messages"][-1]
    tool_calls = last_assistant_msg.get("tool_calls", [])

    # Keine Tools, nichts zu tun
    if not tool_calls:
        return state

    # Alle Tool-Calls ausf√ºhren
    results = []
    for tool in tool_calls:
        function_name = tool["name"]
        arguments = tool["arguments"]

        # Debug-Ausgabe
        if state["debug_mode"]:
            print(f"\n--- DEBUG: Ausf√ºhre {function_name}({', '.join(arguments)}) ---")

        # Funktion ausf√ºhren, falls vorhanden
        if function_name in FUNCTION_MAP:
            func = FUNCTION_MAP[function_name]

            # Argumente an die Funktion √ºbergeben
            if len(arguments) == 0:
                result = func(state)
            elif len(arguments) == 1:
                result = func(state, arguments[0])
            elif len(arguments) == 2:
                result = func(state, arguments[0], arguments[1])
            else:
                result = f"Fehler: Zu viele Argumente f√ºr {function_name}!"

            results.append({
                "name": function_name,
                "result": result
            })

            # Pr√ºfe auf Spielende
            if function_name == "beenden":
                state["game_over"] = True
        else:
            results.append({
                "name": function_name,
                "result": f"Fehler: Unbekannte Funktion {function_name}!"
            })

    # Ergebnisse zum Zustand hinzuf√ºgen
    state["messages"][-1]["tool_results"] = results

    return state


def format_response(state: GameState):
    """Formatiert die Antwort des Systems f√ºr die Ausgabe."""
    # Die letzte Antwort des LLM und der Tools abrufen
    last_assistant_msg = state["messages"][-1]
    content = last_assistant_msg["content"]

    # Tool-Ergebnisse formatieren, falls vorhanden
    tool_results = last_assistant_msg.get("tool_results", [])

    # Grundlegende Formatierung
    formatted_response = content

    # Tool-Ergebnisse hinzuf√ºgen
    if tool_results and state["debug_mode"]:
        formatted_response += "\n\n--- Tool-Ergebnisse ---"
        for result in tool_results:
            formatted_response += f"\n{result['name']}: {result['result']}"

    # F√ºge Raumbeschreibung hinzu, wenn der Raum gewechselt wurde
    current_room = state["current_room"]
    if current_room == "freiheit":
        formatted_response += "\n\nüéâ Gl√ºckwunsch! Du hast das Spiel erfolgreich beendet! üéâ"

    # F√ºge Inventar hinzu, wenn angefragt
    inventory_requested = any(tool["name"] == "inventory" for tool in last_assistant_msg.get("tool_calls", []))
    if inventory_requested:
        inventory_content = inventory(state)
        if "Dein Inventar ist leer" in inventory_content:
            formatted_response += f"\n\nüì¶ {inventory_content}"
        else:
            formatted_response += f"\n\nüì¶ Dein Inventar enth√§lt: {', '.join(state['inventory'])}"

    # Update der Nachrichten
    state["messages"][-1]["formatted_content"] = formatted_response

    return state


def should_end(state: GameState):
    """Pr√ºft, ob das Spiel beendet werden soll."""
    # Pr√ºfe, ob das Spiel-Ende-Flag gesetzt ist
    if state["game_over"]:
        return "end"

    # Pr√ºfe, ob der Spieler im Freiheits-Raum ist (Spielgewinn)
    if state["current_room"] == "freiheit":
        # Lass dem Spieler eine letzte Nachricht sehen
        return None

    # Das Spiel geht weiter
    return None


# Erstellen des Zustandsgraphen
def create_game_graph():
    """Erstellt den Spielzustandsgraphen mit Langgraph."""
    # Erstelle einen neuen Zustandsgraphen
    builder = StateGraph(GameState)

    # Hauptzust√§nde und -√ºberg√§nge definieren
    builder.add_node("process_input", process_input)
    builder.add_node("execute_tools", execute_tools)
    builder.add_node("format_response", format_response)

    # Kanten des Graphen definieren
    builder.set_entry_point("process_input")
    builder.add_edge("process_input", "execute_tools")
    builder.add_edge("execute_tools", "format_response")

    # Entscheidungspunkt: Spiel beenden oder weitermachen
    builder.add_conditional_edges(
        "format_response",
        should_end,
        {
            "end": END,
            None: "process_input"
        }
    )

    # Graph kompilieren
    return builder.compile()


def initialize_game():
    """Initialisiert einen neuen Spielzustand."""
    return {
        "messages": [],  # Leerer Chat-Verlauf
        "current_room": "start",  # Startraum
        "inventory": [],  # Leeres Inventar
        "discovered": {},  # Keine speziellen Entdeckungen
        "visited_rooms": ["start"],  # Startraum ist bereits besucht
        "debug_mode": False,  # Debug-Modus anfangs aus
        "game_over": False  # Spiel l√§uft anfangs
    }


def run_game():
    """Startet und f√ºhrt das Spiel aus."""
    print("=" * 60)
    print("Willkommen zu deinem Text-Adventure!")
    print("Gib 'umsehen' ein, um deine Umgebung zu betrachten.")
    print("Gib 'hilfe' ein, um Tipps zu bekommen.")
    print("Gib 'ende' ein, um das Spiel zu beenden.")
    print("=" * 60)

    # Initialisiere den Spielzustand
    state = initialize_game()

    # Erstelle den Spielgraphen
    game = create_game_graph()

    # Erste Raumbeschreibung
    print("\n" + ROOMS[state["current_room"]]["beschreibung"])

    # Hauptspielschleife
    while True:
        # Benutzereingabe
        user_input = input("\n> ")

        # Aktualisiere die Nachrichten
        state["messages"].append({
            "role": "user",
            "content": user_input
        })

        # F√ºhre den Spielgraphen mit der aktuellen Eingabe aus
        state = game.invoke(state)

        # Formatierte Antwort anzeigen
        print("\n" + state["messages"][-1].get("formatted_content", ""))

        # Pr√ºfe, ob das Spiel beendet ist
        if state["game_over"]:
            print("\nDas Spiel wurde beendet. Bis zum n√§chsten Mal!")
            break


# Haupteinstiegspunkt
if __name__ == "__main__":
    run_game()